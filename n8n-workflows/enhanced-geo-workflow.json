{
  "name": "3cubed-seo-enhanced-geo-optimization",
  "nodes": [
    {
      "id": "webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [250, 300],
      "parameters": {
        "httpMethod": "POST",
        "path": "generate-pharma-geo-content"
      }
    },
    {
      "id": "perplexity_geo_generation",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [450, 300],
      "parameters": {
        "url": "https://api.perplexity.ai/chat/completions",
        "method": "POST",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer {{ $credentials.perplexityApiKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "model",
              "value": "llama-3.1-sonar-large-128k-online"
            },
            {
              "name": "messages",
              "value": "={{ JSON.stringify([{role: 'user', content: `Generate comprehensive pharmaceutical GEO content for: ${$json.product_name}\n\nREGULATORY CONTEXT:\n- FDA/EMA Status: ${$json.fda_ema_approval_status || 'Not specified'}\n- Development Stage: ${$json.development_stage || 'Not specified'}\n- Patient Population: ${$json.patient_population || 'Not specified'}\n- Therapeutic Area: ${$json.therapeutic_area || 'Not specified'}\n\nGEO OPTIMIZATION REQUIREMENTS:\n1. Voice Search Optimization - Generate 10+ natural language voice queries\n2. AI Platform Optimization - Create platform-specific content for ChatGPT, Perplexity, Google SGE, Claude\n3. Clinical Evidence Integration - Include trial data, efficacy, safety profiles\n4. Multi-Modal Content - FAQ sections, how-to guides, infographic descriptions\n5. Regulatory Compliance - Include contraindications, warnings, disclaimers\n\nOUTPUT FORMAT - Return valid JSON with these exact field names:\n{\n  \"seo_title\": \"60-char SEO title\",\n  \"geo_event_tags\": [\"tag1\", \"tag2\"],\n  \"h2_tags\": [\"heading1\", \"heading2\"],\n  \"seo_strategy_outline\": \"SEO strategy text\",\n  \"fda_ema_approval_status\": {\"status\": \"approved/pending\", \"date\": \"YYYY-MM-DD\"},\n  \"key_clinical_trials\": [{\"name\": \"trial_name\", \"phase\": \"phase_3\", \"results\": \"outcome\"}],\n  \"voice_search_queries\": [\"natural voice query 1\", \"query 2\"],\n  \"conversational_starters\": [{\"platform\": \"chatgpt\", \"starter\": \"conversation starter\"}],\n  \"chatgpt_optimization\": {\"tone\": \"professional\", \"structure\": \"Q&A\", \"score\": 85},\n  \"perplexity_optimization\": {\"citation_style\": \"medical\", \"depth\": \"comprehensive\", \"score\": 90},\n  \"google_sge_optimization\": {\"snippet_targets\": [\"fact1\", \"fact2\"], \"score\": 88},\n  \"claude_optimization\": {\"reasoning_style\": \"analytical\", \"examples\": true, \"score\": 92},\n  \"faq_sections\": [{\"question\": \"How does this work?\", \"answer\": \"Detailed answer\"}],\n  \"quick_facts\": [{\"fact\": \"Key benefit\", \"source\": \"Clinical trial\"}],\n  \"key_takeaways\": [\"Important point 1\", \"Important point 2\"],\n  \"ai_readiness_score\": 85,\n  \"content_freshness_score\": 95\n}`}]) }}"
            },
            {
              "name": "temperature",
              "value": "0.7"
            },
            {
              "name": "max_tokens",
              "value": "4000"
            }
          ]
        }
      }
    },
    {
      "id": "content_parser",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [650, 300],
      "parameters": {
        "jsCode": "// Parse and validate Perplexity response\nconst response = $input.item.json;\nlet content;\n\ntry {\n  // Extract content from Perplexity response\n  const messageContent = response.choices[0].message.content;\n  \n  // Try to parse JSON from the response\n  const jsonMatch = messageContent.match(/\\{[\\s\\S]*\\}/);\n  if (jsonMatch) {\n    content = JSON.parse(jsonMatch[0]);\n  } else {\n    throw new Error('No valid JSON found in response');\n  }\n  \n  // Validate required fields\n  const requiredFields = ['seo_title', 'voice_search_queries', 'ai_readiness_score'];\n  const missingFields = requiredFields.filter(field => !content[field]);\n  \n  if (missingFields.length > 0) {\n    throw new Error(`Missing required fields: ${missingFields.join(', ')}`);\n  }\n  \n  // Ensure arrays are properly formatted\n  const arrayFields = ['geo_event_tags', 'h2_tags', 'voice_search_queries', 'key_takeaways'];\n  arrayFields.forEach(field => {\n    if (content[field] && !Array.isArray(content[field])) {\n      content[field] = [content[field]];\n    }\n  });\n  \n  // Set default scores if missing\n  content.ai_readiness_score = content.ai_readiness_score || 75;\n  content.content_freshness_score = content.content_freshness_score || 80;\n  \n  return {\n    submission_id: $input.item.json.submission_id || $input.item.json.id,\n    content: content,\n    parsing_status: 'success',\n    processing_start_time: new Date().toISOString()\n  };\n  \n} catch (error) {\n  return {\n    submission_id: $input.item.json.submission_id || $input.item.json.id,\n    parsing_status: 'failed',\n    error_message: error.message,\n    raw_response: response\n  };\n}"
      }
    },
    {
      "id": "claude_qa_validation",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [850, 300],
      "parameters": {
        "url": "https://api.anthropic.com/v1/messages",
        "method": "POST",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer {{ $credentials.claudeApiKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "anthropic-version",
              "value": "2023-06-01"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "model",
              "value": "claude-3-haiku-20240307"
            },
            {
              "name": "max_tokens",
              "value": "1000"
            },
            {
              "name": "messages",
              "value": "={{ JSON.stringify([{role: 'user', content: `PHARMACEUTICAL GEO CONTENT QA VALIDATION\n\nProduct: ${$json.content?.seo_title || 'Unknown'}\n\nContent to Review:\n${JSON.stringify($json.content, null, 2)}\n\nVALIDATION CHECKLIST:\n\n1. REGULATORY COMPLIANCE ✓\n   - FDA/EMA status present and realistic\n   - Clinical trial data credible\n   - Safety information appropriate\n\n2. GEO OPTIMIZATION QUALITY ✓\n   - Voice search queries natural and relevant (min 5)\n   - AI platform optimizations specific and actionable\n   - FAQ sections comprehensive\n   - Quick facts accurate and useful\n\n3. CONTENT STRUCTURE ✓\n   - SEO title under 60 characters\n   - H2 tags descriptive and keyword-rich\n   - Key takeaways clear and valuable\n   - AI readiness score justified\n\n4. PHARMACEUTICAL ACCURACY ✓\n   - Medical terminology correct\n   - Claims substantiated\n   - Regulatory disclaimers appropriate\n\nRESPOND WITH JSON:\n{\n  \"qa_status\": \"PASS|REVISIONS_NEEDED|FAIL\",\n  \"compliance_score\": 0-100,\n  \"geo_optimization_score\": 0-100,\n  \"content_quality_score\": 0-100,\n  \"feedback\": \"Specific feedback\",\n  \"required_revisions\": [\"specific improvements needed\"]\n}`}]) }}"
            }
          ]
        }
      }
    },
    {
      "id": "qa_parser",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1050, 300],
      "parameters": {
        "jsCode": "// Parse Claude QA response\nconst response = $input.item.json;\nlet qaResults;\n\ntry {\n  const messageContent = response.content[0].text;\n  const jsonMatch = messageContent.match(/\\{[\\s\\S]*\\}/);\n  \n  if (jsonMatch) {\n    qaResults = JSON.parse(jsonMatch[0]);\n  } else {\n    throw new Error('No valid JSON found in QA response');\n  }\n  \n  // Validate QA status\n  if (!['PASS', 'REVISIONS_NEEDED', 'FAIL'].includes(qaResults.qa_status)) {\n    qaResults.qa_status = 'REVISIONS_NEEDED';\n  }\n  \n  // Ensure scores are numbers\n  qaResults.compliance_score = parseInt(qaResults.compliance_score) || 75;\n  qaResults.geo_optimization_score = parseInt(qaResults.geo_optimization_score) || 75;\n  qaResults.content_quality_score = parseInt(qaResults.content_quality_score) || 75;\n  \n  return {\n    ...$input.item.json,\n    qa_results: qaResults,\n    qa_status: qaResults.qa_status,\n    overall_score: Math.round((qaResults.compliance_score + qaResults.geo_optimization_score + qaResults.content_quality_score) / 3)\n  };\n  \n} catch (error) {\n  return {\n    ...$input.item.json,\n    qa_status: 'FAIL',\n    qa_error: error.message,\n    qa_results: {\n      qa_status: 'FAIL',\n      feedback: 'QA validation failed due to parsing error',\n      compliance_score: 0,\n      geo_optimization_score: 0,\n      content_quality_score: 0\n    }\n  };\n}"
      }
    },
    {
      "id": "qa_router",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 1,
      "position": [1250, 300],
      "parameters": {
        "dataType": "string",
        "value1": "={{ $json.qa_status }}",
        "rules": {
          "rules": [
            {
              "value2": "PASS",
              "output": 0
            },
            {
              "value2": "REVISIONS_NEEDED",
              "output": 1
            },
            {
              "value2": "FAIL",
              "output": 2
            }
          ]
        }
      }
    },
    {
      "id": "geo_performance_tracker",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1450, 200],
      "parameters": {
        "jsCode": "// Calculate comprehensive GEO performance metrics\nconst content = $input.item.json.content;\nconst qaResults = $input.item.json.qa_results;\nconst endTime = new Date();\nconst startTime = new Date($input.item.json.processing_start_time);\n\n// Calculate field completion rate\nfunction calculateFieldCompletion(content) {\n  const geoFields = [\n    'voice_search_queries', 'conversational_starters', 'chatgpt_optimization',\n    'perplexity_optimization', 'google_sge_optimization', 'claude_optimization',\n    'faq_sections', 'quick_facts', 'key_takeaways', 'fda_ema_approval_status',\n    'key_clinical_trials'\n  ];\n  \n  const completedFields = geoFields.filter(field => {\n    const value = content[field];\n    return value && value !== null && value !== '' && \n           (Array.isArray(value) ? value.length > 0 : true);\n  }).length;\n  \n  return Math.round((completedFields / geoFields.length) * 100);\n}\n\n// Calculate voice optimization score\nfunction calculateVoiceOptimization(content) {\n  const voiceQueries = content.voice_search_queries || [];\n  const conversationalStarters = content.conversational_starters || [];\n  \n  let score = 0;\n  if (voiceQueries.length >= 5) score += 40;\n  if (voiceQueries.length >= 10) score += 20;\n  if (conversationalStarters.length >= 3) score += 25;\n  if (content.question_based_headings?.length >= 3) score += 15;\n  \n  return Math.min(score, 100);\n}\n\nconst geoMetrics = {\n  processing_time_ms: endTime - startTime,\n  field_completion_rate: calculateFieldCompletion(content),\n  voice_optimization_score: calculateVoiceOptimization(content),\n  ai_platform_scores: {\n    chatgpt: content.chatgpt_optimization?.score || 0,\n    perplexity: content.perplexity_optimization?.score || 0,\n    google_sge: content.google_sge_optimization?.score || 0,\n    claude: content.claude_optimization?.score || 0\n  },\n  overall_ai_readiness: content.ai_readiness_score || 0,\n  content_freshness: content.content_freshness_score || 0,\n  qa_scores: {\n    compliance: qaResults.compliance_score || 0,\n    geo_optimization: qaResults.geo_optimization_score || 0,\n    content_quality: qaResults.content_quality_score || 0\n  },\n  processed_at: endTime.toISOString()\n};\n\nreturn {\n  ...$input.item.json,\n  geo_performance_metrics: geoMetrics,\n  final_processing_status: 'completed'\n};"
      }
    },
    {
      "id": "save_geo_content",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [1650, 200],
      "parameters": {
        "operation": "update",
        "table": "submissions",
        "filters": {
          "conditions": [
            {
              "field": "id",
              "value": "={{ $json.submission_id }}"
            }
          ]
        },
        "updateFields": {
          "ai_output": "={{ JSON.stringify($json.content) }}",
          "seo_title": "={{ $json.content.seo_title }}",
          "geo_event_tags": "={{ $json.content.geo_event_tags }}",
          "h2_tags": "={{ $json.content.h2_tags }}",
          "seo_strategy_outline": "={{ $json.content.seo_strategy_outline }}",
          "fda_ema_approval_status": "={{ JSON.stringify($json.content.fda_ema_approval_status) }}",
          "key_clinical_trials": "={{ JSON.stringify($json.content.key_clinical_trials) }}",
          "voice_search_queries": "={{ $json.content.voice_search_queries }}",
          "conversational_starters": "={{ JSON.stringify($json.content.conversational_starters) }}",
          "chatgpt_optimization": "={{ JSON.stringify($json.content.chatgpt_optimization) }}",
          "perplexity_optimization": "={{ JSON.stringify($json.content.perplexity_optimization) }}",
          "google_sge_optimization": "={{ JSON.stringify($json.content.google_sge_optimization) }}",
          "claude_optimization": "={{ JSON.stringify($json.content.claude_optimization) }}",
          "ai_readiness_score": "={{ $json.content.ai_readiness_score }}",
          "faq_sections": "={{ JSON.stringify($json.content.faq_sections) }}",
          "quick_facts": "={{ JSON.stringify($json.content.quick_facts) }}",
          "key_takeaways": "={{ $json.content.key_takeaways }}",
          "geo_performance_metrics": "={{ JSON.stringify($json.geo_performance_metrics) }}",
          "content_freshness_score": "={{ $json.content.content_freshness_score }}",
          "workflow_stage": "seo_review",
          "ai_processing_status": "completed",
          "langchain_status": "completed"
        }
      }
    },
    {
      "id": "revision_handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1450, 400],
      "parameters": {
        "jsCode": "// Handle revisions with enhanced feedback\nconst revisionCount = $input.item.json.revision_count || 0;\nconst qaResults = $input.item.json.qa_results;\n\nif (revisionCount >= 2) {\n  return {\n    ...$input.item.json,\n    action: 'fail',\n    reason: `Maximum revisions (2) reached. Issues: ${qaResults.feedback}`,\n    final_status: 'failed_max_revisions'\n  };\n}\n\n// Prepare enhanced revision prompt\nconst revisionPrompt = `\nREVISION REQUIRED - Attempt ${revisionCount + 1}/2\n\nOriginal Product: ${$input.item.json.content?.seo_title || 'Unknown'}\n\nQA Feedback: ${qaResults.feedback}\n\nRequired Improvements:\n${qaResults.required_revisions?.join('\\n- ') || 'General improvements needed'}\n\nScores to Improve:\n- Compliance: ${qaResults.compliance_score}/100\n- GEO Optimization: ${qaResults.geo_optimization_score}/100  \n- Content Quality: ${qaResults.content_quality_score}/100\n\nFocus on addressing the specific feedback above while maintaining all other quality aspects.\n`;\n\nreturn {\n  ...$input.item.json,\n  action: 'revise',\n  revision_count: revisionCount + 1,\n  revision_prompt: revisionPrompt,\n  previous_content: $input.item.json.content\n};"
      }
    },
    {
      "id": "error_handler",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [1650, 600],
      "parameters": {
        "operation": "update",
        "table": "submissions",
        "filters": {
          "conditions": [
            {
              "field": "id",
              "value": "={{ $json.submission_id }}"
            }
          ]
        },
        "updateFields": {
          "workflow_stage": "failed",
          "ai_processing_status": "failed",
          "langchain_status": "failed",
          "langchain_error": "={{ $json.qa_results?.feedback || $json.error_message || 'GEO optimization failed' }}",
          "processing_notes": "={{ JSON.stringify({error_type: 'geo_optimization_failure', qa_scores: $json.qa_results, timestamp: new Date().toISOString()}) }}"
        }
      }
    }
  ],
  "connections": {
    "webhook": {
      "main": [
        [
          {
            "node": "perplexity_geo_generation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "perplexity_geo_generation": {
      "main": [
        [
          {
            "node": "content_parser",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "content_parser": {
      "main": [
        [
          {
            "node": "claude_qa_validation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "claude_qa_validation": {
      "main": [
        [
          {
            "node": "qa_parser",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "qa_parser": {
      "main": [
        [
          {
            "node": "qa_router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "qa_router": {
      "main": [
        [
          {
            "node": "geo_performance_tracker",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "revision_handler",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "error_handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "geo_performance_tracker": {
      "main": [
        [
          {
            "node": "save_geo_content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "revision_handler": {
      "main": [
        [
          {
            "node": "perplexity_geo_generation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  }
}